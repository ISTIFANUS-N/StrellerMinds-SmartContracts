#[cfg(test)]
mod expiry_integration_tests {
    use super::*;
    use soroban_sdk::{testutils::{Address as _, Ledger, LedgerInfo}, Address, Env};
    use crate::{
        Certificate, CertificateClient,
        types::{CertificateStatus, MintCertificateParams, RenewalStatus, NotificationType},
        errors::CertificateError,
    };

    fn create_test_env() -> (Env, Address, Address, Address) {
        let env = Env::default();
        let admin = Address::generate(&env);
        let instructor = Address::generate(&env);
        let student = Address::generate(&env);
        
        env.mock_all_auths();
        
        (env, admin, instructor, student)
    }

    #[test]
    fn test_complete_renewal_workflow() {
        let (env, admin, instructor, student) = create_test_env();
        let contract_id = env.register_contract(None, Certificate);
        let client = CertificateClient::new(&env, &contract_id);
        
        // Step 1: Mint certificate
        let certificate_id = soroban_sdk::BytesN::from_array(&env, &[1u8; 32]);
        let params = MintCertificateParams {
            certificate_id: certificate_id.clone(),
            student: student.clone(),
            course_id: "COURSE_001".into_val(&env),
            title: "Integration Test Certificate".into_val(&env),
            description: "Testing complete renewal workflow".into_val(&env),
            metadata_uri: "https://example.com/metadata".into_val(&env),
            expiry_date: env.ledger().timestamp() + 86400 * 30, // 30 days
        };
        
        client.mint_certificate(&instructor, &params);
        
        let original_cert = client.get_certificate(&certificate_id).unwrap();
        assert_eq!(original_cert.status, CertificateStatus::Active);
        assert_eq!(original_cert.renewal_count, 0);
        
        // Step 2: Request renewal
        let extension_period = 86400 * 60; // 60 days
        let reason = "Continuing education program".into_val(&env);
        
        client.request_certificate_renewal(&student, &certificate_id, &extension_period, &reason);
        
        let renewal_request = client.get_renewal_request(&certificate_id).unwrap();
        assert_eq!(renewal_request.status, RenewalStatus::Pending);
        assert_eq!(renewal_request.requested_extension, extension_period);
        
        // Step 3: Admin approves renewal
        let admin_reason = Some("Approved for continued studies".into_val(&env));
        client.process_renewal_request(&admin, &certificate_id, &true, &admin_reason);
        
        // Step 4: Verify renewal completed
        let renewed_cert = client.get_certificate(&certificate_id).unwrap();
        assert_eq!(renewed_cert.status, CertificateStatus::Renewed);
        assert_eq!(renewed_cert.renewal_count, 1);
        assert!(renewed_cert.expiry_date > original_cert.expiry_date);
        assert!(renewed_cert.last_renewed_date > 0);
        
        let final_request = client.get_renewal_request(&certificate_id).unwrap();
        assert_eq!(final_request.status, RenewalStatus::Approved);
    }

    #[test]
    fn test_expiry_notification_lifecycle() {
        let (env, admin, instructor, student) = create_test_env();
        let contract_id = env.register_contract(None, Certificate);
        let client = CertificateClient::new(&env, &contract_id);
        
        // Create certificate expiring soon
        let certificate_id = soroban_sdk::BytesN::from_array(&env, &[1u8; 32]);
        let current_time = env.ledger().timestamp();
        let params = MintCertificateParams {
            certificate_id: certificate_id.clone(),
            student: student.clone(),
            course_id: "COURSE_001".into_val(&env),
            title: "Expiring Certificate".into_val(&env),
            description: "Testing notification lifecycle".into_val(&env),
            metadata_uri: "https://example.com/metadata".into_val(&env),
            expiry_date: current_time + 86400 * 7, // 7 days from now
        };
        
        client.mint_certificate(&instructor, &params);
        
        // Simulate time progression and check notifications
        
        // Day 1: No notifications yet (certificate expires in 6 days)
        env.ledger().with_mut(|li| {
            li.timestamp = current_time + 86400;
        });
        
        let notifications = client.get_expiry_notifications(&student);
        let warning_notifications: Vec<_> = notifications
            .iter()
            .filter(|n| n.certificate_id == certificate_id)
            .collect();
        assert!(warning_notifications.is_empty());
        
        // Day 4: Should have 7-day warning (certificate expires in 3 days)
        env.ledger().with_mut(|li| {
            li.timestamp = current_time + 86400 * 4;
        });
        
        // In a real implementation, notifications would be generated by a background process
        // For testing, we assume the system has generated appropriate notifications
        
        // Day 6: Should have 1-day warning (certificate expires in 1 day)
        env.ledger().with_mut(|li| {
            li.timestamp = current_time + 86400 * 6;
        });
        
        // Day 8: Certificate should be expired
        env.ledger().with_mut(|li| {
            li.timestamp = current_time + 86400 * 8;
        });
        
        // Update expired certificates
        let updated_count = client.update_expired_certificates();
        assert!(updated_count.is_ok());
        
        let expired_cert = client.get_certificate(&certificate_id).unwrap();
        assert_eq!(expired_cert.status, CertificateStatus::Expired);
    }

    #[test]
    fn test_bulk_operations_with_mixed_results() {
        let (env, admin, instructor, student) = create_test_env();
        let contract_id = env.register_contract(None, Certificate);
        let client = CertificateClient::new(&env, &contract_id);
        
        // Create multiple certificates with different states
        let mut certificate_ids = soroban_sdk::Vec::new(&env);
        
        // Active certificate
        let cert_id_1 = soroban_sdk::BytesN::from_array(&env, &[1u8; 32]);
        let params_1 = MintCertificateParams {
            certificate_id: cert_id_1.clone(),
            student: student.clone(),
            course_id: "COURSE_001".into_val(&env),
            title: "Active Certificate".into_val(&env),
            description: "Active certificate".into_val(&env),
            metadata_uri: "https://example.com/metadata".into_val(&env),
            expiry_date: env.ledger().timestamp() + 86400 * 30,
        };
        client.mint_certificate(&instructor, &params_1);
        certificate_ids.push_back(cert_id_1.clone());
        
        // Revoked certificate
        let cert_id_2 = soroban_sdk::BytesN::from_array(&env, &[2u8; 32]);
        let params_2 = MintCertificateParams {
            certificate_id: cert_id_2.clone(),
            student: student.clone(),
            course_id: "COURSE_002".into_val(&env),
            title: "Revoked Certificate".into_val(&env),
            description: "Certificate to be revoked".into_val(&env),
            metadata_uri: "https://example.com/metadata".into_val(&env),
            expiry_date: env.ledger().timestamp() + 86400 * 30,
        };
        client.mint_certificate(&instructor, &params_2);
        client.revoke_certificate(&admin, &cert_id_2);
        certificate_ids.push_back(cert_id_2.clone());
        
        // Non-existent certificate
        let cert_id_3 = soroban_sdk::BytesN::from_array(&env, &[99u8; 32]);
        certificate_ids.push_back(cert_id_3.clone());
        
        // Attempt bulk extension
        let new_expiry_date = env.ledger().timestamp() + 86400 * 90;
        let reason = "Bulk extension test".into_val(&env);
        
        let result = client.bulk_extend_certificates(
            &admin,
            &certificate_ids,
            &new_expiry_date,
            &reason
        );
        
        // Should succeed but only extend valid certificates
        assert!(result.is_ok());
        let successful_ids = result.unwrap();
        
        // Only cert_id_1 should be successfully extended
        assert_eq!(successful_ids.len(), 1);
        assert_eq!(successful_ids.get(0).unwrap(), cert_id_1);
        
        // Verify the active certificate was extended
        let extended_cert = client.get_certificate(&cert_id_1).unwrap();
        assert_eq!(extended_cert.expiry_date, new_expiry_date);
        assert_eq!(extended_cert.renewal_count, 1);
        
        // Verify revoked certificate was not modified
        let revoked_cert = client.get_certificate(&cert_id_2).unwrap();
        assert_eq!(revoked_cert.status, CertificateStatus::Revoked);
        assert_eq!(revoked_cert.renewal_count, 0);
    }

    #[test]
    fn test_renewal_request_edge_cases() {
        let (env, admin, instructor, student) = create_test_env();
        let contract_id = env.register_contract(None, Certificate);
        let client = CertificateClient::new(&env, &contract_id);
        
        // Create certificate
        let certificate_id = soroban_sdk::BytesN::from_array(&env, &[1u8; 32]);
        let params = MintCertificateParams {
            certificate_id: certificate_id.clone(),
            student: student.clone(),
            course_id: "COURSE_001".into_val(&env),
            title: "Edge Case Certificate".into_val(&env),
            description: "Testing edge cases".into_val(&env),
            metadata_uri: "https://example.com/metadata".into_val(&env),
            expiry_date: env.ledger().timestamp() + 86400 * 30,
        };
        client.mint_certificate(&instructor, &params);
        
        // Test 1: Request with zero extension period
        let result = client.try_request_certificate_renewal(
            &student,
            &certificate_id,
            &0u64,
            &"Zero extension".into_val(&env)
        );
        assert!(result.is_err()); // Should fail validation
        
        // Test 2: Request with extremely long extension period
        let max_extension = 86400 * 365 * 10; // 10 years
        let result = client.try_request_certificate_renewal(
            &student,
            &certificate_id,
            &max_extension,
            &"Very long extension".into_val(&env)
        );
        // Depending on implementation, this might succeed or fail based on limits
        
        // Test 3: Request renewal for expired certificate
        // First, let certificate expire
        env.ledger().with_mut(|li| {
            li.timestamp = li.timestamp + 86400 * 35; // 35 days later
        });
        
        client.update_expired_certificates();
        
        let result = client.try_request_certificate_renewal(
            &student,
            &certificate_id,
            &(86400 * 30),
            &"Renewal for expired cert".into_val(&env)
        );
        assert!(result.is_err()); // Should fail for expired certificate
    }

    #[test]
    fn test_concurrent_renewal_operations() {
        let (env, admin, instructor, student) = create_test_env();
        let contract_id = env.register_contract(None, Certificate);
        let client = CertificateClient::new(&env, &contract_id);
        
        // Create certificate
        let certificate_id = soroban_sdk::BytesN::from_array(&env, &[1u8; 32]);
        let params = MintCertificateParams {
            certificate_id: certificate_id.clone(),
            student: student.clone(),
            course_id: "COURSE_001".into_val(&env),
            title: "Concurrent Test Certificate".into_val(&env),
            description: "Testing concurrent operations".into_val(&env),
            metadata_uri: "https://example.com/metadata".into_val(&env),
            expiry_date: env.ledger().timestamp() + 86400 * 30,
        };
        client.mint_certificate(&instructor, &params);
        
        // Create renewal request
        client.request_certificate_renewal(
            &student,
            &certificate_id,
            &(86400 * 30),
            &"First renewal request".into_val(&env)
        );
        
        // Try admin extension while renewal request is pending
        let result = client.try_extend_certificate_expiry(
            &admin,
            &certificate_id,
            &(86400 * 60),
            &"Admin extension during pending renewal".into_val(&env)
        );
        
        // This should either succeed (if implementation allows) or fail gracefully
        // The exact behavior depends on the business logic implementation
        
        // Process the renewal request
        client.process_renewal_request(
            &admin,
            &certificate_id,
            &true,
            &Some("Approved after admin extension".into_val(&env))
        );
        
        // Verify final state is consistent
        let final_cert = client.get_certificate(&certificate_id).unwrap();
        assert!(final_cert.renewal_count > 0);
        assert!(final_cert.last_renewed_date > 0);
    }

    #[test]
    fn test_gas_optimization_bulk_operations() {
        let (env, admin, instructor, student) = create_test_env();
        let contract_id = env.register_contract(None, Certificate);
        let client = CertificateClient::new(&env, &contract_id);
        
        // Create maximum allowed certificates for bulk operation (50)
        let mut certificate_ids = soroban_sdk::Vec::new(&env);
        for i in 0..50 {
            let cert_id = soroban_sdk::BytesN::from_array(&env, &[i as u8; 32]);
            let params = MintCertificateParams {
                certificate_id: cert_id.clone(),
                student: student.clone(),
                course_id: format!("COURSE_{:03}", i).into_val(&env),
                title: format!("Bulk Test Certificate {}", i).into_val(&env),
                description: "Bulk operation test".into_val(&env),
                metadata_uri: "https://example.com/metadata".into_val(&env),
                expiry_date: env.ledger().timestamp() + 86400 * 30,
            };
            client.mint_certificate(&instructor, &params);
            certificate_ids.push_back(cert_id);
        }
        
        // Test bulk extension with maximum allowed certificates
        let new_expiry_date = env.ledger().timestamp() + 86400 * 90;
        let reason = "Maximum bulk extension test".into_val(&env);
        
        let result = client.bulk_extend_certificates(
            &admin,
            &certificate_ids,
            &new_expiry_date,
            &reason
        );
        
        assert!(result.is_ok());
        let successful_ids = result.unwrap();
        assert_eq!(successful_ids.len(), 50);
        
        // Test exceeding bulk operation limit (51 certificates)
        let extra_cert_id = soroban_sdk::BytesN::from_array(&env, &[51u8; 32]);
        let extra_params = MintCertificateParams {
            certificate_id: extra_cert_id.clone(),
            student: student.clone(),
            course_id: "COURSE_051".into_val(&env),
            title: "Extra Certificate".into_val(&env),
            description: "Testing limit exceeded".into_val(&env),
            metadata_uri: "https://example.com/metadata".into_val(&env),
            expiry_date: env.ledger().timestamp() + 86400 * 30,
        };
        client.mint_certificate(&instructor, &extra_params);
        certificate_ids.push_back(extra_cert_id);
        
        let result = client.try_bulk_extend_certificates(
            &admin,
            &certificate_ids,
            &new_expiry_date,
            &reason
        );
        
        // Should fail due to exceeding bulk operation limit
        assert!(result.is_err());
    }

    #[test]
    fn test_notification_acknowledgment_workflow() {
        let (env, admin, instructor, student) = create_test_env();
        let contract_id = env.register_contract(None, Certificate);
        let client = CertificateClient::new(&env, &contract_id);
        
        // Create certificate that will expire soon
        let certificate_id = soroban_sdk::BytesN::from_array(&env, &[1u8; 32]);
        let params = MintCertificateParams {
            certificate_id: certificate_id.clone(),
            student: student.clone(),
            course_id: "COURSE_001".into_val(&env),
            title: "Notification Test Certificate".into_val(&env),
            description: "Testing notification acknowledgment".into_val(&env),
            metadata_uri: "https://example.com/metadata".into_val(&env),
            expiry_date: env.ledger().timestamp() + 86400 * 7, // 7 days
        };
        client.mint_certificate(&instructor, &params);
        
        // Simulate time passing to generate notifications
        env.ledger().with_mut(|li| {
            li.timestamp = li.timestamp + 86400 * 6; // 6 days later (1 day before expiry)
        });
        
        // In a real system, notifications would be generated automatically
        // For testing, we'll acknowledge a notification that should exist
        
        let result = client.acknowledge_notification(&student, &certificate_id);
        assert!(result.is_ok());
        
        // Verify notification was acknowledged
        let notifications = client.get_expiry_notifications(&student);
        let acknowledged_notifications: Vec<_> = notifications
            .iter()
            .filter(|n| n.certificate_id == certificate_id && n.acknowledged)
            .collect();
        
        // Should have at least one acknowledged notification
        assert!(!acknowledged_notifications.is_empty());
    }
}
